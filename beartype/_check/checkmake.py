#!/usr/bin/env python3
# --------------------( LICENSE                            )--------------------
# Copyright (c) 2014-2025 Beartype authors.
# See "LICENSE" for further details.

'''
**Beartype type-checking function code factories** (i.e., low-level
callables dynamically generating pure-Python code snippets type-checking
arbitrary objects passed to arbitrary callables against PEP-compliant type hints
passed to those same callables).

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ IMPORTS                            }....................
from beartype._cave._cavemap import NoneTypeOr
from beartype._check.convert.convmain import sanify_hint_root_statement
from beartype._check.code.codemain import make_check_expr
from beartype._check.error.errmain import (
    get_func_pith_violation,
    get_hint_object_violation,
)
from beartype._check.metadata.call.callmetaabc import BeartypeCallMetaABC
from beartype._check.metadata.call.callmetadecor import BeartypeCallDecorMeta
from beartype._check.metadata.call.callmetaexternal import (
    BEARTYPE_CALL_EXTERNAL_META)
from beartype._check.metadata.hint.hintsane import (
    HINT_SANE_IGNORABLE,
    HintSane,
)
from beartype._check.signature.sigmake import make_func_signature
from beartype._conf.confmain import BeartypeConf
from beartype._conf.conftest import die_unless_conf
from beartype._data.code.datacodename import (
    ARG_NAME_CALL_META,
    ARG_NAME_CONF,
    ARG_NAME_EXCEPTION_PREFIX,
    ARG_NAME_GETRANDBITS,
    ARG_NAME_GET_VIOLATION,
    ARG_NAME_HINT,
    ARG_NAME_WARN,
    CODE_PITH_ROOT_NAME_PLACEHOLDER,
    FUNC_CHECKER_NAME_PREFIX,
)
from beartype._data.code.func.datacodefunccheck import (
    CODE_CHECKER_SIGNATURE,
    CODE_RAISER_FUNC_PITH_CHECK_PREFIX,
    CODE_RAISER_HINT_OBJECT_CHECK_PREFIX,
    CODE_TESTER_CHECK_PREFIX,
    CODE_GET_FUNC_PITH_VIOLATION,
    CODE_GET_HINT_OBJECT_VIOLATION,
    CODE_GET_VIOLATION_RANDOM_INT,
    CODE_RAISE_VIOLATION,
    CODE_WARN_VIOLATION,
)
from beartype._data.error.dataerrmagic import EXCEPTION_PLACEHOLDER
from beartype._data.func.datafuncarg import ARG_NAME_RETURN_REPR
from beartype._data.typing.datatypingport import Hint
from beartype._data.typing.datatyping import (
    CallableRaiserOrTester,
    CodeGenerated,
    LexicalScope,
)
from beartype._util.cache.utilcachecall import callable_cached
from beartype._util.error.utilerrraise import reraise_exception_placeholder
from beartype._util.error.utilerrwarn import reissue_warnings_placeholder
from beartype._util.func.utilfuncmake import make_func
from collections.abc import Callable
from itertools import count
from typing import Optional
from warnings import (
    catch_warnings,
    warn,
)

# ....................{ CONSTANTS                          }....................
# Human-readable constants intended to be passed as the values of the
# "pith_kind" parameter accepted by the _make_code_raiser_violation() function
# factory. These values comprise a tri-state boolean. Since the higher-level
# make_code_raiser_func_pith_check() code factory accepts *ONLY* a strict
# (rather than tri-state) boolean, these constants are intentionally *NOT*
# defined as enumeration members.

PITH_KIND_FUNC_ARG = True
'''
Value of the ``pith_kind`` parameter accepted by the
:func:`._make_code_raiser_violation` function factory signifying the object
accepted by the type-checking raiser function created and returned by that
factory to be a **function parameter** (e.g., passed to a type-checking wrapper
function dynamically generated by the :func:`beartype.beartype` decorator).
'''


PITH_KIND_FUNC_RETURN = False
'''
Value of the ``pith_kind`` parameter accepted by the
:func:`._make_code_raiser_violation` function factory signifying the object
accepted by the type-checking raiser function created and returned by that
factory to be a **function return** (e.g., returned from a type-checking wrapper
function dynamically generated by the :func:`beartype.beartype` decorator).
'''


PITH_KIND_NONFUNC_OBJECT = None
'''
Value of the ``pith_kind`` parameter accepted by the
:func:`._make_code_raiser_violation` function factory signifying the object
accepted by the type-checking raiser function created and returned by that
factory to be an **arbitrary object** (e.g., passed to the
:func:`beartype.door.die_if_unbearable` raiser function).
'''

# ....................{ HINTS                              }....................
TupleHintConfStr = tuple[Hint, BeartypeConf, str]
'''
Type hint matching each three 3-tuple ``(hint, conf, exception_prefix)`` of all
parameters accepted by the :func:`.make_func_checker` function factory.
'''

# ....................{ FACTORIES ~ func                   }....................
#FIXME: Unit test us up, please.
def make_func_checker(
    hint: Hint,
    conf: BeartypeConf,
    exception_prefix: str,
    make_code_check: Callable[..., CodeGenerated],
    hint_conf_exception_prefix_to_func_checker: (
        dict[TupleHintConfStr, CallableRaiserOrTester]),
) -> CallableRaiserOrTester:
    '''
    **Type-checking function factory** (i.e., low-level callable dynamically
    generating a pure-Python function detecting whether an arbitrary object
    passed to that function satisfies the type hint passed to this factory and
    either returning that result as its boolean return *or* raising a fatal
    exception or emitting a non-fatal warning if that result is :data:`False`).

    This factory underlies both the public
    :func:`beartype.door.die_if_unbearable` and
    :func:`beartype.door.is_bearable` statement-level type-checking functions.

    This factory is effectively memoized by the
    ``hint_conf_exception_prefix_to_func_checker`` dictionary passed to this
    factory for the proper subset of type hints whose type-checking code is
    safely memoizable. See also that dictionary's docstring for further details.

    Caveats
    -------
    **This factory intentionally accepts no** ``exception_cls`` **parameter.**
    Doing so would only ambiguously obscure context-sensitive exceptions raised
    by lower-level utility functions called by this higher-level factory.

    **This factory dynamically resolves all** :pep:`484`-compliant **forward
    reference type hints visitable from this type hint** against the first
    external lexical scope on the call stack originating from a third-party
    module or package. For efficiency, this factory does so by internally
    delegating forward hint resolution to the **beartype external call metadata
    singleton** (i.e., :data:`.BEARTYPE_CALL_EXTERNAL_META` global).


    Parameters
    ----------
    hint : Hint
        Type hint to be type-checked.
    conf : BeartypeConf
        **Beartype configuration** (i.e., self-caching dataclass encapsulating
        all settings configuring type-checking for the passed object).
    exception_prefix : str
        Human-readable substring prefixing raised exception messages.
    make_code_check : Callable[..., CodeGenerated]
        **Type-checking code factory** (i.e., function dynamically generating a
        code snippet of a function type-checking an arbitrary object against the
        passed type hint under the passed beartype configuration).
    hint_conf_exception_prefix_to_func_checker : dict[TupleHintConfStr, CallableRaiserOrTester]
        **Type-checking function factory cache** (i.e., dictionary mapping from
        each 3-tuple ``(hint, conf, exception_prifx)`` of these parameters to
        the type-checking function dynamically generated by this factory).

    Returns
    -------
    CallableRaiserOrTester
        Function type-checking this hint against this configuration under this
        beartype call metadata.

    Raises
    ------
    All exceptions raised by the lower-level :func:`.make_check_expr` factory.
    Additionally, this factory also raises:

    BeartypeConfException
        If this configuration is *not* a :class:`.BeartypeConf` instance.
    BeartypeDecorHintForwardRefException
        If this hint contains one or more relative forward references, which
        this factory explicitly prohibits to improve both the efficiency and
        portability of calls by users to the resulting type-checker.
    _BeartypeUtilCallableException
        If this function erroneously generates a syntactically invalid
        type-checking function. That should *never* happen, but let's admit that
        you're still reading this for a reason.

    Warns
    -----
    All warnings emitted by the lower-level :func:`.make_check_expr` factory.
    '''

    # True only if the function dynamically generated by this factory is safely
    # memoizable back into this cache, defaulting to true.
    is_func_cacheable = True

    # Object with which to cache the function dynamically generated by this
    # factory. Since that function conditionally depends on these parameters,
    # this is the 3-tuple aggregating these objects.
    #
    # Note that this object is hashable if and only if this hint is hashable.
    # Since a proper subset of PEP-compliant hints are unhashable (e.g.,
    # "Annotated[str, []]"), this cache key *COULD* be unhashable.
    CACHE_KEY = (hint, conf, exception_prefix)

    # Attempt to...
    try:
        # Either:
        # * If this hint is safely memoizable *AND* this function factory has
        #   already been passed the same parameters, the function previously
        #   generated by that call.
        # * Else, "None".
        func_checker = hint_conf_exception_prefix_to_func_checker.get(CACHE_KEY)

        # If a prior call to this factory has already generated a function
        # type-checking these parameters, return that function.
        if func_checker is not None:
            return func_checker
        # Else, this is the first call to this factory passed these parameters.
    # If the dictionary lookup above raised the standard "TypeError" exception,
    # this hint is unhashable. In this case...
    except TypeError:
        # Record that the function dynamically generated by this factory
        # *CANNOT* be safely memoized back into this cache.
        is_func_cacheable = False

    # Validate parameter sanity.
    #
    # Note that we avoid doing so above as a negligible micro-optimization.
    assert callable(make_code_check), f'{repr(make_code_check)} uncallable.'

    # Attempt to...
    #
    # Note that the passed "exception_prefix" is intentionally *NOT* passed to
    # functions in the body of this "try" block. Why? Memoization efficiency.
    # Instead, the placeholder "EXCEPTION_PLACEHOLDER" is intentionally passed.
    # The "except" block then catches and replaces that with "exception_prefix".
    try:
        # With a context manager "catching" *ALL* non-fatal warnings emitted
        # during this logic for subsequent "playback" below...
        with catch_warnings(record=True) as warnings_issued:
            # ....................{ VALIDATION             }....................
            # If "conf" is *NOT* a configuration, raise an exception.
            die_unless_conf(conf)
            # Else, "conf" is a configuration.

            # Beartype external call metadata singleton, enabling logic below to
            # dynamically resolve *ALL* PEP 484-compliant forward reference type
            # hints visitable from this hint against the first external lexical
            # scope on the call stack originating from a third-party package.
            call_meta = BEARTYPE_CALL_EXTERNAL_META

            # Metadata encapsulating the sanification of this possibly insane
            # hint if this hint is supported by @beartype *OR* raise an
            # exception otherwise (i.e., if this hint is unsupported).
            #
            # Do this first *BEFORE* passing this hint to any further callables.
            hint_sane = sanify_hint_root_statement(
                call_meta=call_meta,
                conf=conf,
                hint=hint,
                exception_prefix=EXCEPTION_PLACEHOLDER,
            )
            # print(f'Reduced tester root hint {repr(hint)} to hint or metadata {repr(hint_sane)}.')

            # If this hint is ignorable, all objects satisfy this hint. In this
            # case, return a trivial function unconditionally returning true.
            if hint_sane is HINT_SANE_IGNORABLE:
                # print(f'[_make_func_checker] Ignoring ignorable hint {hint} with conf {conf}!')
                return _func_checker_ignorable
            # Else, this hint is unignorable.

            # ....................{ CODE                   }....................
            # Python code snippet comprising a single boolean expression
            # type-checking an arbitrary object against this hint.
            #
            # Note that this call (and *ONLY* this call) is intentionally passed
            # the "exception_prefix" parameter rather than the
            # "EXCEPTION_PLACEHOLDER" placeholder. Why? Because this call
            # dynamically generates code raising type-checking violations
            # prefixed by this prefix at a later time rather than *NOW*. Passing
            # "EXCEPTION_PLACEHOLDER" would, in particular, erroneously cause
            # the public beartype.door.die_if_unbearable() type-checker to raise
            # unreadable type-checking violations prefixed by
            # "EXCEPTION_PLACEHOLDER" (which is an unreadable placeholder).
            code_check, func_scope = make_code_check(
                call_meta,
                hint,
                hint_sane,
                conf,
                exception_prefix,
            )
            # print(f'func_scope: {func_scope}')

            # Expose this beartype external call metadata singleton to this
            # wrapper function as a beartype-specific hidden parameter passed to
            # this wrapper function, whose default value is that metadata. Doing
            # so simplifies calls to the get_hint_object_violation() getter in
            # the body of this wrapper function by enabling this metadata to be
            # passed as a single unified parameter (rather than individually as
            # multiple distinct parameters).
            func_scope[ARG_NAME_CALL_META] = call_meta

            # Unqualified basename of this type-checking function to be created,
            # uniquified by suffixing an arbitrary integer unique to this
            # function.
            func_checker_name = (
                f'{FUNC_CHECKER_NAME_PREFIX}{next(_func_checker_name_counter)}')

            # Python code snippet declaring the signature of the type-checking
            # function function to be defined and returned by this factory.
            code_signature = make_func_signature(
                func_name=func_checker_name,
                func_scope=func_scope,
                code_signature_format=CODE_CHECKER_SIGNATURE,
                conf=conf,
            )

            # Python code snippet defining this type-checking function in full.
            func_checker_code = f'{code_signature}{code_check}'

            # ....................{ FUNCTION               }....................
            # Type-checking function to be returned.
            # print(f'Making checker {repr(func_checker_name)} with conf {conf}...')
            func_checker = make_func(
                func_name=func_checker_name,
                func_code=func_checker_code,
                func_locals=func_scope,
                func_label=EXCEPTION_PLACEHOLDER,
                is_debug=conf.is_debug,
            )

            # If that function is safely memoizable, do so.
            if is_func_cacheable:
                hint_conf_exception_prefix_to_func_checker[CACHE_KEY] = (
                    func_checker)
            # Else, that function is *NOT* safely memoizable.
        # If one or more warnings were issued, reissue these warnings with each
        # placeholder substring (i.e., "EXCEPTION_PLACEHOLDER" instance)
        # replaced by a human-readable description of this callable and
        # annotated return.
        if warnings_issued:
            reissue_warnings_placeholder(
                warnings=warnings_issued, target_str=exception_prefix)
        # Else, *NO* warnings were issued.
    # If doing so raises *ANY* exception, reraise this exception with each
    # placeholder substring (i.e., "EXCEPTION_PLACEHOLDER" instance) replaced by
    # an explanatory prefix.
    except Exception as exception:
        reraise_exception_placeholder(
            exception=exception, target_str=exception_prefix)

    # Return that function.
    return func_checker

# ....................{ FACTORIES ~ code                   }....................
#FIXME: Unit test us up, please.
@callable_cached
def make_code_raiser_hint_object_check(
    call_meta: BeartypeCallMetaABC,
    hint_insane: Hint,
    hint_sane: HintSane,
    conf: BeartypeConf,
    exception_prefix: str,
) -> CodeGenerated:
    '''
    Pure-Python code snippet of a type-checking raiser function type-checking an
    arbitrary object against the passed type hint under the passed beartype
    configuration by either raising a fatal exception *or* emitting a non-fatal
    warning when that object violates this hint.

    This factory underlies the public :func:`beartype.door.die_if_unbearable`
    type-checking raiser function.

    This factory is memoized for efficiency.

    Parameters
    ----------
    call_meta : BeartypeCallMetaABC
        **Beartype call metadata** (i.e., dataclass aggregating *all* common
        metadata encapsulating the lexical scope of the external call to the
        public :func:`beartype.door.die_if_unbearable` raiser function).
    hint_insane : Hint
        Possibly **insane** (i.e., pre-sanified) type hint to be type-checked.
    hint_sane : HintSane
        Metadata encapsulating the sanification of this type hint.
    conf : BeartypeConf
        **Beartype configuration** (i.e., self-caching dataclass encapsulating
        all settings configuring type-checking for the passed object).
    exception_prefix : str
        Human-readable substring prefixing raised exception messages.

    Returns
    -------
    CodeGenerated
        Tuple containing the Python code snippet dynamically generated by this
        code factory and metadata describing that code. See the
        :attr:`beartype._data.typing.datatyping.CodeGenerated` type hint.

    See Also
    --------
    :func:`.make_check_expr`
        Further details.
    '''

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # CAUTION: Synchronize with the make_code_raiser_func_pith_check() factory.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Python code snippet comprising a single boolean expression type-checking
    # an arbitrary object against this hint.
    code_expr, func_scope = make_check_expr(
        call_meta=call_meta, hint_sane=hint_sane, conf=conf)

    # Pass hidden parameters to this raiser function exposing:
    # * The passed exception prefix accessed by this snippet.
    # * The get_hint_object_violation() getter called by the
    #   "CODE_GET_HINT_OBJECT_VIOLATION" snippet.
    # * The passed *INSANE* type hint accessed by this snippet. Why insane?
    #   Because the mere act of sanifying this hint typically reduces this hint
    #   from having a terse readable to verbose unreadable representation in
    #   violation messages raised by this raiser function. An insane hint is
    #   preferable for the purposes of generating readable violations.
    func_scope[ARG_NAME_EXCEPTION_PREFIX] = exception_prefix
    func_scope[ARG_NAME_GET_VIOLATION] = get_hint_object_violation
    func_scope[ARG_NAME_HINT] = hint_insane

    #FIXME: [SPEED] Globalize this bound method as a negligible efficiency gain.
    # Code snippet generating a human-readable violation exception or warning
    # when the root pith violates the root type hint.
    code_get_violation = CODE_GET_HINT_OBJECT_VIOLATION.format(
        arg_random_int=_get_func_scope_arg_random_int(func_scope))

    # Code snippet handling the previously generated violation by either raising
    # that violation as a fatal exception or emitting that violation as a
    # non-fatal warning.
    code_handle_violation = _make_code_raiser_violation(
        conf=conf, func_scope=func_scope)

    # Code snippet type-checking the root pith against the root hint.
    func_code = (
        f'{CODE_RAISER_HINT_OBJECT_CHECK_PREFIX}'
        f'{code_expr}'
        f'{code_get_violation}'
        f'{code_handle_violation}'
    )

    # Return all metadata required by higher-level callers.
    return (func_code, func_scope)


#FIXME: Unit test us up, please.
@callable_cached
def make_code_tester_check(
    call_meta: BeartypeCallMetaABC,
    hint_insane: Hint,
    hint_sane: HintSane,
    conf: BeartypeConf,
    exception_prefix : str,
) -> CodeGenerated:
    '''
    Pure-Python code snippet of a type-checking tester function type-checking an
    arbitrary object against the passed type hint under the passed beartype
    configuration by returning whether that object satisfies this hint or not.

    This factory underlies the public :func:`beartype.door.is_bearable`
    type-checking tester function.

    This factory is memoized for efficiency.

    Parameters
    ----------
    call_meta : BeartypeCallMetaABC
        **Beartype call metadata** (i.e., dataclass aggregating *all* common
        metadata encapsulating the lexical scope of the external call to the
        public :func:`beartype.door.is_bearable` tester function).
    hint_insane : Hint
        Possibly **insane** (i.e., pre-sanified) type hint to be type-checked.
    hint_sane : HintSane
        Metadata encapsulating the sanification of this type hint.
    conf : BeartypeConf
        **Beartype configuration** (i.e., self-caching dataclass encapsulating
        all settings configuring type-checking for the passed object).
    exception_prefix : str
        Human-readable substring prefixing raised exception messages.

    Returns
    -------
    CodeGenerated
        Tuple containing the Python code snippet dynamically generated by this
        code factory and metadata describing that code. See the
        :attr:`beartype._data.typing.datatyping.CodeGenerated` type hint.

    See Also
    --------
    :func:`.make_check_expr`
        Further details.
    '''

    # Python code snippet comprising a single boolean expression type-checking
    # an arbitrary object against this hint.
    code_expr, func_scope = make_check_expr(
        call_meta=call_meta, hint_sane=hint_sane, conf=conf)

    # Code snippet type-checking the root pith against the root hint.
    func_code = f'{CODE_TESTER_CHECK_PREFIX}{code_expr}'

    # Return all metadata required by higher-level callers.
    return (func_code, func_scope)

# ....................{ FACTORIES ~ code : raiser          }....................
@callable_cached
def make_code_raiser_func_pep484_noreturn_check(
    conf: BeartypeConf) -> CodeGenerated:
    '''
    Pure-Python code snippet of a type-checking raiser function type-checking a
    return of a decorated callable against the :obj:`typing.NoReturn` type hint
    annotating that return under the passed beartype configuration by either
    raising a fatal exception *or* emitting a non-fatal warning when that
    callable violates this hint by itself failing to raise an exception.

    This factory is memoized for efficiency.

    Parameters
    ----------
    conf : BeartypeConf
        **Beartype configuration** (i.e., self-caching dataclass encapsulating
        all settings configuring type-checking for the passed object).

    Returns
    -------
    CodeGenerated
        Tuple containing the Python code snippet dynamically generated by this
        code factory and metadata describing that code. See the
        :attr:`beartype._data.typing.datatyping.CodeGenerated` type hint.
    '''

    # Lexical scope to be returned, initialized to the empty dictionary.
    func_scope = {}

    # Pass hidden parameters to this raiser function exposing the
    # get_func_pith_violation() getter called by the
    # "CODE_GET_FUNC_PITH_VIOLATION" snippet.
    func_scope[ARG_NAME_GET_VIOLATION] = get_func_pith_violation

    #FIXME: [SPEED] Globalize CODE_GET_FUNC_PITH_VIOLATION_format(), please.
    # Code snippet generating a human-readable violation exception or warning
    # when the root pith violates the root type hint.
    code_get_violation = CODE_GET_FUNC_PITH_VIOLATION.format(
        arg_random_int='', pith_name=ARG_NAME_RETURN_REPR)

    # Code snippet handling the previously generated violation by either raising
    # that violation as a fatal exception or emitting that violation as a
    # non-fatal warning.
    code_handle_violation = _make_code_raiser_violation(
        conf=conf, func_scope=func_scope, pith_kind=PITH_KIND_FUNC_RETURN)

    # Code snippet type-checking the root pith against the root hint.
    func_code = f'{code_get_violation}{code_handle_violation}'

    # Return all metadata required by higher-level callers.
    return (func_code, func_scope)

# ....................{ FACTORIES ~ code : raiser : pith   }....................
#FIXME: Unit test us up, please.
@callable_cached
def make_code_raiser_func_pith_check(
    decor_meta: BeartypeCallDecorMeta,
    hint_sane: HintSane,
    pith_kind: bool,
) -> CodeGenerated:
    '''
    Pure-Python code snippet of a type-checking raiser function type-checking a
    parameter or return of a decorated callable against the passed type hint
    under the passed beartype configuration by either raising a fatal exception
    *or* emitting a non-fatal warning when that parameter or return violates
    this hint.

    This factory is memoized for efficiency.

    Parameters
    ----------
    decor_meta : BeartypeCallDecorMeta
        **Beartype decorator call metadata** (i.e., dataclass aggregating *all*
        metadata encapsulating the currently decorated callable).
    hint_sane : HintSane
        Metadata encapsulating the sanification of the hint to be type-checked.
    pith_kind : bool
        If the **pith** (i.e., object being type-checked by the code snippet
        generated and returned by this factory) type-checks a previously
        localized:

        * **Parameter** accepted by a decorated callable, :data:`True`.
        * **Return** returned from a decorated callable, :data:`False`.

        Note that, while it would be simpler for this factory to instead accept
        a pith name, doing so would also unmemoize this factory as well as all
        higher-level factories calling this factory.

    Returns
    -------
    CodeGenerated
        Tuple containing the Python code snippet dynamically generated by this
        code factory and metadata describing that code. See the
        :attr:`beartype._data.typing.datatyping.CodeGenerated` type hint.

    See Also
    --------
    :func:`.make_check_expr`
        Further details.
    '''
    assert isinstance(decor_meta, BeartypeCallDecorMeta), (
        f'{repr(decor_meta)} not beartype decorator call metadata.')

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # CAUTION: Synchronize with the make_code_hint_object_check() factory.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Python code snippet comprising a single boolean expression type-checking
    # an arbitrary object against this hint.
    code_expr, func_scope = make_check_expr(
        call_meta=decor_meta, hint_sane=hint_sane, conf=decor_meta.conf)

    # Expose the get_func_pith_violation() getter called by the
    # "CODE_GET_FUNC_PITH_VIOLATION" snippet as a "beartype"-specific hidden
    # parameter passed to this wrapper function.
    func_scope[ARG_NAME_GET_VIOLATION] = get_func_pith_violation

    #FIXME: [SPEED] Globalize CODE_GET_FUNC_PITH_VIOLATION.format() as
    #"CODE_GET_FUNC_PITH_VIOLATION_format". *sigh*
    # Code snippet generating a human-readable violation exception or warning
    # when the root pith violates the root type hint.
    code_get_violation = CODE_GET_FUNC_PITH_VIOLATION.format(
        arg_random_int=_get_func_scope_arg_random_int(func_scope),
        pith_name=CODE_PITH_ROOT_NAME_PLACEHOLDER,
    )

    # Code snippet handling the previously generated violation by either raising
    # that violation as a fatal exception or emitting that violation as a
    # non-fatal warning.
    code_handle_violation = _make_code_raiser_violation(
        conf=decor_meta.conf, func_scope=func_scope, pith_kind=pith_kind)

    # Code snippet type-checking the root pith against the root hint.
    func_code = (
        f'{CODE_RAISER_FUNC_PITH_CHECK_PREFIX}'
        f'{code_expr}'
        f'{code_get_violation}'
        f'{code_handle_violation}'
    )

    # Return all metadata required by higher-level callers.
    return (func_code, func_scope)

# ....................{ PRIVATE ~ globals                  }....................
_func_checker_name_counter = count(start=0, step=1)
'''
**Type-checking function name uniquifier** (i.e., iterator yielding the next
integer incrementation starting at 0, leveraged by the
:func:`._make_func_checker` factory to uniquify the names of the type-checking
functions dynamically generated by that factory).
'''

# ....................{ PRIVATE ~ testers                  }....................
def _func_checker_ignorable(obj: object) -> bool:
    '''
    **Ignorable type-checking tester function singleton** (i.e., function
    unconditionally returning :data:`True`, semantically equivalent to a tester
    testing whether an arbitrary object passed to this tester satisfies an
    ignorable type hint).

    The :func:`make_func_tester` factory efficiently returns this singleton when
    passed an ignorable type hint rather than inefficiently regenerating a
    unique ignorable type-checking tester function for that hint.
    '''

    return True

# ....................{ PRIVATE ~ getters                  }....................
#FIXME: Unit test us up, please.
def _get_func_scope_arg_random_int(func_scope: LexicalScope) -> str:
    '''
    Code snippet intended to be embedded as the ``arg_random_int`` format
    variable of either the parent :data:`.CODE_GET_HINT_OBJECT_VIOLATION` or
    :data:`.CODE_GET_FUNC_PITH_VIOLATION` code snippets.

    Parameters
    ----------
    func_scope : LexicalScope
        **Lexical scope** (i.e., dictionary mapping from the relative
        unqualified name to value of each locally or globally scoped attribute
        accessible to a callable or class).

    Returns
    -------
    str
        Either:

        * If the passed lexical scope accepts a random integer generator, a code
          snippet passing the value of the random integer previously generated
          by that generator for the current call of a high-level type-checking
          function to a call as a keyword parameter to a lower-level
          type-checking exception raiser function call.
        * Else, the empty string.
    '''
    assert isinstance(func_scope, dict), f'{repr(func_scope)} not dictionary.'

    # Return either...
    return (
        # If this lexical scope accepts a random integer generator, the code
        # snippet described above;
        CODE_GET_VIOLATION_RANDOM_INT
        if ARG_NAME_GETRANDBITS in func_scope else
        # Else, the empty string.
        ''
    )

# ....................{ PRIVATE ~ factories : code         }....................
def _make_code_raiser_violation(
    # Mandatory parameters.
    conf: BeartypeConf,
    func_scope: LexicalScope,

    # Optional parameters.
    pith_kind: Optional[bool] = PITH_KIND_NONFUNC_OBJECT,
) -> str:
    '''
    Pure-Python code snippet of a **type-checking raiser function** (i.e.,
    dynamically generated by the :func:`.make_raiser_func` factory) either
    raising a fatal exception or emitting a non-fatal warning when an arbitrary
    object violates an arbitrary type hint under the passed beartype
    configuration in the body of that raiser.

    This factory is intentionally *not* memoized (e.g., by the
    ``@callable_cached`` decorator), as this factory is only called by
    higher-level memoized factories.

    Parameters
    ----------
    conf : BeartypeConf
        **Beartype configuration** (i.e., self-caching dataclass encapsulating
        all settings configuring type-checking for the passed object).
    func_scope : LexicalScope
        **Lexical scope** (i.e., dictionary mapping from the relative
        unqualified name to value of each locally or globally scoped attribute
        accessible to a callable or class).
    pith_kind : Optional[bool], default: PITH_KIND_NONFUNC_OBJECT
        **Tri-state pith boolean.** Although it would be simpler for this
        factory to accept a pith name, doing so would effectively unmemoize all
        higher-level memoized factories calling this code factory. If the code
        snippet generated and returned by this code factory type-checks a
        previously localized:

        * Parameter of a decorated callable, :data:`PITH_KIND_FUNC_ARG`.
        * Return of a decorated callable, :data:`PITH_KIND_FUNC_RETURN`.
        * Arbitrary object passed to the parent
          :func:`beartype.door.die_if_uncallable` type-checker,
          :data:`PITH_KIND_NONFUNC_OBJECT`.

        Defaults to :data:`PITH_KIND_NONFUNC_OBJECT` for simplicity and readability.

    Returns
    -------
    CodeGenerated
        Tuple containing the Python code snippet dynamically generated by this
        code factory and metadata describing that code. See the
        :attr:`beartype._data.typing.datatyping.CodeGenerated` type hint for
        details.

    Raises
    ------
    All exceptions raised by the lower-level :func:`make_check_expr` factory.

    Warns
    -----
    All warnings emitted by the lower-level :func:`make_check_expr` factory.

    See Also
    --------
    :func:`.make_check_expr`
        Further details.
    '''
    assert isinstance(conf, BeartypeConf), f'{repr(conf)} not configuration.'
    assert isinstance(func_scope, dict), f'{repr(func_scope)} not dictionary.'
    assert isinstance(pith_kind, NoneTypeOr[bool]), (
        f'{repr(pith_kind)} neither boolean nor "None".')

    # Pass a hidden parameter to this raiser function exposing the passed
    # beartype configuration accessed by this snippet.
    func_scope[ARG_NAME_CONF] = conf

    # Code snippet handling the previously generated violation by either raising
    # that violation as a fatal exception or emitting that violation as a
    # non-fatal warning, contextually initialized below.
    code_violation = ''  # type: ignore[assignment]

    # If this code snippet produces this violation by emitting a non-fatal
    # warning (rather than raising an exception), detected as either...
    if (
        # If this object is neither a parameter nor return of a decorated
        # callable, this object was directly passed to either the
        # beartype.door.is_bearable() or beartype.door.die_if_unbearable()
        # functions. In either case, set this boolean to this previously
        # computed DOOR-specific boolean.
        conf._is_violation_door_warn
        if pith_kind is PITH_KIND_NONFUNC_OBJECT else
        # Else, this object is either a parameter or return of a decorated
        # callable.
        #
        # If this object is be a parameter of a decorated callable, set this
        # boolean to this previously computed parameter-specific boolean.
        conf._is_violation_param_warn
        if pith_kind is PITH_KIND_FUNC_ARG else
        # Else, this object is *NOT* a parameter of a decorated callable. In this
        # case, this object *MUST* be a return of a decorated callable. Set
        # this boolean to this previously computed return-specific boolean.
        conf._is_violation_return_warn
    ):
        # Emit a non-fatal warning.
        code_violation = CODE_WARN_VIOLATION

        # Pass the warnings.warn() function required to emit this warning to
        # this wrapper function as an optional hidden parameter.
        #
        # Note that we intentionally do *NOT* pass the higher-level
        # issue_warning() function. Why? Efficiency, mostly. Recall that
        # issue_warning() is *ONLY* called to pretend that warnings generated by
        # callables both defined by and residing in this codebase are actually
        # generated by external third-party code. Although this wrapper function
        # is also generated by callables defined by this codebase (including
        # this callable, of course), this wrapper function does *NOT* reside
        # inside this codebase but instead effectively resides inside the
        # external third-party module defining the original function this
        # wrapper function wraps. Needlessly passing issue_warning() rather than
        # warn() here would only consume CPU cycles for *NO* tangible gain.
        func_scope[ARG_NAME_WARN] = warn
    # Else, raise a fatal exception.
    else:
        code_violation = CODE_RAISE_VIOLATION

    # Return this code snippet.
    return code_violation
