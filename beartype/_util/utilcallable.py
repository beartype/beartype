#!/usr/bin/env python3
# --------------------( LICENSE                           )--------------------
# Copyright (c) 2014-2021 Cecil Curry.
# See "LICENSE" for further details.

'''
**Beartype callable utilities.**

This private submodule implements supplementary callable-specific utility
functions required by various :mod:`beartype` facilities, including callables
generated by the :func:`beartype.beartype` decorator.

This private submodule is *not* intended for importation by downstream callers.
'''

#FIXME: Rename this entire submodule to the new "beartype._util.func.utilfunc".
#Once we start dynamically inspecting callables ourselves rather than relying
#on the "inspect" module, we're going to have a plethora of these sorts of
#submodules lying around. Huzzah!

# ....................{ IMPORTS                            }....................
import sys
import os.path

from collections.abc import Callable
from beartype.cave import ClassType, CallableCTypes

from beartype.roar import _BeartypeUtilCallableException
# ....................{ GETTERS                           }....................
def get_callable_filename_or_placeholder(func: Callable) -> str:
    '''
    Absolute filename of the uncompiled Python script or module physically
    declaring the passed callable if any *or* the placeholder string
    ``"<string>"`` implying this callable to have been dynamically declared
    in-memory otherwise.

    Parameters
    ----------
    func : Callable
        Callable to be inspected.

    Returns
    ----------
    str
        Either:

        * If this callable is physically declared by an uncompiled Python
          script or module, the absolute filename of this script or module.
        * Else, the placeholder string ``"<string>"`` implying this callable to
          have been dynamically declared in-memory.

    See Also
    ----------
    :func:`inspect.getsourcefile`
        Inefficient stdlib function strongly inspiring this implementation,
        which has been highly optimized for use by the performance-sensitive
        :func:`beartype.beartype` decorator.
    '''
    if callable(func) is False:
        raise _BeartypeUtilCallableException(
            f"Attempted to pass non-callable:{repr(func)}")

   # Grab location of the module declaring class
    elif isinstance(func, type):

        # Check the Class has a module thats registered with the system.
        if (getattr(func,"__module__", None) and
            sys.modules.get(func.__module__) and
            getattr(sys.modules.get(func.__module__),"__file__", None)):
            filename = os.path.abspath(sys.modules.get(func.__module__).__file__)
        # Class was dynamically declared.
        else:
            filename = "<string>"
    else:
        # Built-in types are callables with no .py source file.
        if isinstance(func,CallableCTypes):
            filename = "<builtin>"
        # Check the function/method contains a code object with the declaring filename.
        elif (getattr(func, "__code__", None) and
              getattr(func.__code__, "co_filename", None)):
            filename = os.path.abspath(func.__code__.co_filename)
        # Callable was dynamically declared.
        else:
            filename = "<string>"

    return filename
