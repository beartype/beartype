#!/usr/bin/env python3
# --------------------( LICENSE                            )--------------------
# Copyright (c) 2014-2025 Beartype authors.
# See "LICENSE" for further details.

'''
**Beartype import hook API.**

This subpackage publishes :pep:`302`- and :pep:`451`-compliant import hooks
enabling external callers to automatically decorate well-typed third-party
packages and modules with runtime type-checking dynamically generated by the
:func:`beartype.beartype` decorator in a single line of code.
'''

# ....................{ TODO                               }....................
#FIXME: *OH, BOY.* We just realized that we can now effectively quell two
#long-standing feature requests with one commit. Well, many commits, probably.
#But the core idea isn't *TOO* hard, surprisingly. These feature requests are:
#1. Third-party import hook creation. Currently, creating third-party import
#   hooks is *HIGHLY* non-trivial. I'm still not convinced that any third-party
#   package except @beartype has gotten it fully correct. Ignoring correctness,
#   third-party import hooks do *NOT* play nicely with one another. They don't
#   apply each other's AST transforms. They violate DRY by duplicating the hard
#   work of defining an import hook across each third-party package.
#2. Implicit "jaxtyping" integration. Currently, @beartype integrates with
#   "jaxtyping" via the latter's install_import_hook() function: e.g.,
#       from jaxtyping import install_import_hook
#       install_import_hook('my_library_name', 'beartype.beartype')
#   That's non-ideal, as that import hook *ONLY* applies the "jaxtyping" AST
#   transform. @beartype's AST transform is *NOT* applied by that import hook.
#
#Here's how we resolve both with the minimum of both fuss and muss:
#* Publicize our existing AST transform. This isn't strictly necessary, but will
#  make it a lot easier to convince everyone else in this field to publish their
#  own currently mostly private AST transforms:
#      # In the "beartype.claw.__init__" submodule:
#      from beartype.claw._ast.clawastmain import (
#          BeartypeNodeTransformer as BeartypeNodeTransformer)
#* Define a new configuration option resembling:
#      BeartypeConf(ast_transforms: typing.Optional[collections.abc.Collection[
#          Union[ast.NodeTransformer, type[ast.NodeTransformer]]]] = None)
#
#  That is, each "ast_transforms" item may be either:
#  * A user-defined "NodeTransformer" *SUBCLASS*.
#  * A user-defined "NodeTransformer" *INSTANCE*.
#* Define a new "BeartypeJaxtypingNodeTransformer(NodeTransformer):" subclass.
#  The existing private "jaxtyping._import_hook.JaxtypingTransformer" subclass
#  has an incompatible API. Ergo, we need to define a new
#  "BeartypeJaxtypingNodeTransformer" shim with a compatible API that acts as an
#  intercessor between the @beartype and "jaxtyping" codebases. Thankfully, this
#  is largely trivial. We just need to ignore the "typechecking" parameter
#  required by the JaxtypingTransformer.__init__() constructor *AND* fixup line
#  numbers, which "JaxtypingTransformer" itself fails to do.
#
#  Specifically, define a new "beartype.claw._ast.clawastjaxtyping" submodule:
#       from ast import (
#           NodeTransformer,
#           Node,
#           fix_missing_locations,
#       )
#       from beartype.claw._ast.clawastmain import BeartypeNodeTransformer
#
#       class BeartypeJaxtypingNodeTransformer(NodeTransformer):
#           def visit(self, node: Node) -> Node:
#               jaxtyping_transformer = JaxtypingTransformer(typechecking=None)
#               node_jaxtyped = jaxtyping_transformer.visit(node)
#               fix_missing_locations(node_jaxtyped)
#               return node_jaxtyped
#* When "None", this new "ast_transforms" option should default to:
#      if ast_transforms is None:
#          ast_transforms = [BeartypeNodeTransformer]
#
#          try:
#              from beartype.claw._ast.clawastjaxtyping import (
#                  BeartypeJaxtypingNodeTransformer)
#              ast_transforms.append(BeartypeJaxtypingNodeTransformer)
#          except ImportError:
#              pass
#
#          #FIXME: *GLOBALIZE THIS* in a safe way, please. This default *NEVER*
#          #changes across the active Python process. Call it:
#          #    AST_TRANSFORMS_DEFAULT
#          # Coerce from mutable list to immutable tuple as required by
#          # memoization.
#          ast_transforms = tuple(ast_transforms)
#
#  Genius, right? If jaxtyping's private AST transform is conditionally
#  importable, we implicitly apply that *AFTER* @beartype's own AST transform.
#  Order probably doesn't matter... but maybe it does. No idea. Testing needed.
#* Generalize the existing "beartype.claw._importlib._clawimpload" submodule to
#  iteratively apply these "ast_transforms". Specifically, rather than our
#  current crude unintelligent approach:
#      # AST transformer decorating typed callables and classes by @beartype.
#      ast_beartyper = BeartypeNodeTransformer(
#          module_name=self._module_name, conf=self._module_conf)
#
#      # Abstract syntax tree (AST) modified by this transformer.
#      module_ast_beartyped = ast_beartyper.visit(module_ast)
#
#  ...we instead want to embrace this iterative intelligent approach:
#      from ast import NodeTransformer
#
#      module_ast_transformed = module_ast
#      for ast_transform_type_or_obj in self._module_conf.ast_transforms:
#          ast_transform: NodeTransformer = None  # type: ignore[assignment]
#
#          if issubclass(ast_transform_type_or_obj, NodeTransformer):
#              ast_transform = ast_transform_type_or_obj()
#          elif isinstance(ast_transform_type_or_obj, NodeTransformer):
#              ast_transform = ast_transform_type_or_obj
#          else:
#              raise SomeBeartypeException('blah blah')
#
#          # Abstract syntax tree (AST) modified by this transformer.
#          module_ast_transformed = ast_transform.visit(module_ast_transformed)
#
#      # Attempt to...
#      try:
#          # Code object compiled from this transformed AST.
#          module_codeobj = compile(
#              module_ast_transformed,
#              ...
#
#  Super-hot, huh? We know. We know.
#* In the same submodule, generalize our usage of the
#  cache_from_source_beartype() function. Currently, unconditionally
#  monkey-patching that function away suffices: e.g.,
#      _bootstrap_external.cache_from_source = cache_from_source_beartype
#
#  However, the bytecode generated by @beartype import hooks now conditionally
#  depends on the current "conf.ast_transforms" option and thus "conf" itself.
#  In the existing "beartype.claw._importlib.clawimpcache" submodule, we now
#  also need to:
#
#  * Define a new public global:
#        BEARTYPE_CONF_TO_CACHE_FROM_SOURCE: dict[BeartypeConf, Callable] = {}
#  * Refactor the cache_from_source_beartype() function to additionally accept
#    an optional "conf: BeartypeConf" parameter *INSIDE THE BODY OF THIS
#    FUNCTION* with super-weird *kwargs logic. If non-None, the
#    "conf.ast_transforms" collection should then be hashed into the resulting
#    "optimization" marker: e.g.,
#        beartype_conf = kwargs.get('conf', BEARTYPE_CONF_DEFAULT)
#        optimization_marker_beartype_conf = hash(beartype_conf)
#
#        kwargs['optimization'] = (
#            f'{optimization_marker_nonbeartype}
#
#            # Note the delimiting "v" to avoid numerical collisions between
#            # the current beartype version (which suffixes the
#            # "OPTIMIZATION_MARKER_BEARTYPE" magic string) and this hash.
#            f'{OPTIMIZATION_MARKER_BEARTYPE}v'
#            f'{optimization_marker_beartype_conf}
#        )
#
#  Then, back in "beartype.claw._importlib._clawimpload", replace:
#      # This crude unintelligent assignment...
#      _bootstrap_external.cache_from_source = cache_from_source_beartype
#
#      # ...with this much cleverer logic:
#      from beartype.claw._importlib.clawimpcache import (
#          BEARTYPE_CONF_TO_CACHE_FROM_SOURCE)
#      from functools import partial
#
#      cache_from_source_beartype_confed = (
#          BEARTYPE_CONF_TO_CACHE_FROM_SOURCE.get(conf))
#
#      if cache_from_source_beartype_confed is None:
#          cache_from_source_beartype_confed = partial(
#              cache_from_source_beartype, conf=conf)
#          BEARTYPE_CONF_TO_CACHE_FROM_SOURCE[conf] = (
#              cache_from_source_beartype_confed)
#
#      _bootstrap_external.cache_from_source = cache_from_source_beartype_confed
#
#  Actually... we *TOTALLY* should have been doing that already. That's an
#  existing bug. If users currently modify the "BeartypeConf" they pass to a
#  @beartype import hook, that hook will currently fail to regenerate bytecode.
#  *WOOPS.* Better late than never, huh? *sigh*
#
#That's it, actually. A lot of that we should have been doing anyway. None of
#that is particularly arduous, thankfully. Let's dooooooooooo this!!!

#FIXME: The jaxtyping.install_import_hook() import hook has a clever API feature
#that we should crib: it unconditionally returns a context manager which does
#*NOTHING* on __entry__() but which uninstalls the hook on __exit__(). This is
#clever, because it means it preserves backward compatibility with the existing
#@beartype API while additionally enabling the "beartype.claw" API to be only
#conditionally applied within a "with:" block.
#
#*HMM.* Or maybe... not. The issue is threading. Ideally, a context manager in a
#"with:" block should *ONLY* apply to the current thread. Python is obviously
#going thread-free. That'll be the default someday. While clever,
#jaxtyping.install_import_hook() approach unconditionally installs its hook
#globally across *ALL* threads, even when used in a "with:" block. *sigh*

#FIXME: [QA] Technically, we're not quite done here. The "beartype.claw" API
#currently silently ignores attempts to subject the "beartype" package itself to
#@beartyping. Ideally, that API should instead raise human-readable exceptions
#when users explicitly attempt to do so when calling either the
#beartype_package() or beartype_packages() functions. After implementing that
#functionality, assert that in our test suite, please.

# ....................{ IMPORTS                            }....................
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# WARNING: To avoid polluting the public module namespace, external attributes
# should be locally imported at module scope *ONLY* under alternate private
# names (e.g., "from argparse import ArgumentParser as _ArgumentParser" rather
# than merely "from argparse import ArgumentParser").
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
from beartype.claw._clawmain import (
    beartype_all as beartype_all,
    beartype_package as beartype_package,
    beartype_packages as beartype_packages,
    beartype_this_package as beartype_this_package,
)
from beartype.claw._package.clawpkgcontext import (
    beartyping as beartyping,
)
