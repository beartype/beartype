---
# --------------------( LICENSE                           )--------------------
# Copyright (c) 2014-2021 Cecil Curry.
# See "LICENSE" for further details.
#
# --------------------( SYNOPSIS                          )--------------------
# GitHub-specific continuous deployment (CD) configuration, enabling automated
# publication of both source tarballs and binary wheels in various popular
# formats to both GitHub itself and PyPI on each push of a tag to the "master"
# branch of this repository.
#
# --------------------( SEE ALSO                          )--------------------
# * https://blog.chezo.uno/how-to-release-python-package-from-github-actions-d5a1d8edba6e
#   Well-authored blog post strongly inspiring this configuration.
# * https://packaging.python.org/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows
#   Official PyPA workflow also inspiring this configuration.

# ....................{ METADATA                          }....................
# Non-human-readable (i.e., machine-readable) label associated with this
# GitHub Actions workflow.
name: release

# ....................{ TRIGGER                           }....................
# Confine deployment to only new tags satisfying a release-specific format.
on:
  push:
    #FIXME: Uncomment after determining why this induces critical failures on
    #"git push --tags" attempts with remote error messages resembling:
    #    error: dst refspec refs/heads/master matches more than one
    #    error: failed to push some refs to 'git@github.com:beartype/beartype.git'
    #See also: https://github.com/actions/create-release/issues/13
    # branches: [ master ]

    # Sequence of glob expressions matched against "refs/tags" pushed to the
    # branches above.
    tags:
      - 'v*'   # Match "v"-prefixed tags (e.g., "v6.9.6").

# ....................{ MAIN                              }....................
jobs:
  # ...................{ GITHUB                            }...................
  release:
    name: "Create tagged release on GitHub"
    runs-on: ubuntu-latest

    steps:
      - name: "Checking out repository..."
        uses: 'actions/checkout@v2'
      - name: "Publishing GitHub release from tag..."
        uses: 'actions/create-release@v1'
        id: create_release
        env:
          # Boilerplate token auto-generated by GitHub Actions.
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: "beartype ${{ github.ref }}"
          body: ${{ github.event.commits[0].message }}

  # ...................{ PYPI                              }...................
  pypi:
    needs: release

    name: "Publish tagged release to PyPI"
    runs-on: ubuntu-latest

    steps:
      - name: "Checking out repository..."
        uses: 'actions/checkout@v2'
      - name: "Installing latest stable Python 3.x..."
        uses: 'actions/setup-python@v1'
        with:
          python-version: '3.x'

      # See "pythonpackage.yml" for further details.
      - name: 'Installing package dependencies...'
        run: |
          set -xe
          python -VV
          python -m site
          python -m pip install --upgrade pip setuptools wheel
          python -m pip install --upgrade twine
      - name: "Creating source tarball and binary wheel..."
        run: |
          set -xe
          python setup.py sdist bdist_wheel
      - name: "Publishing PyPI release from tag..."
        uses: 'pypa/gh-action-pypi-publish@master'
        with:
          user: __token__
          password: ${{ secrets.pypi_password }}

      #FIXME: Enable after integrating this "pypi" job into the "release" job
      #above. In theory, this should be trivial. Let's test this later, eh?
      # - name: "Publishing GitHub release assets from tag..."
      #   uses: actions/upload-release-asset@v1.0.1
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   with:
      #     upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps
      #     asset_path: "dist/beartype-${{ github.ref }}.zip"
      #     asset_name: "beartype-${{ github.ref }}.zip"
      #     asset_content_type: application/zip
